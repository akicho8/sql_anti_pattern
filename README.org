* 一目で思い出すためのSQLアンチパターン覚え書き

   | 名前                       | 何がダメか                   | 解決方法               | 備考                         |
   |----------------------------+------------------------------+------------------------+------------------------------|
   | 信号無視                   | 1つのカラムにIDを複数格納    | 中間テーブルを持つ     |                              |
   | 複数列属性                 | カラムを連番で増やす         | 適切なリレーション     | xxx2 が出てきたら危険        |
   | 闇雲インデックス           | インデックスを張りまくる     | 絞る                   |                              |
   | 幻のファイル               | カラムにファイルパスを格納   | blob                   |                              |
   | 読み取り可能パスワード     | パスワードを格納             | ハッシュ化             |                              |
   | 31のフレーバー             | 限定する値を列定義(enum)     | 別テーブルで管理       |                              |
   | ランダムセレクション       | order rand()                 | offset rand(count)     |                              |
   | 丸め誤差                   | float                        | decimal                | 緯度経度でありがち           |
   | SQLインジェクション        | where("id = #{params[:id]}") | where(id: params[:id]) |                              |
   | 疑似キー潔癖症             | 欠番を埋めたがる             | 埋めたがらない         |                              |
   | 貧者のサーチエンジン       | like '%foo%'                 | FULLTEXT等             |                              |
   | 魔法の豆                   | モデルに書かない             | 書く                   |                              |
   | typeにモデル名を入れるアレ | 整合性が揺らぐ・柔軟性がない | 使わない               | 便利な面も多い               |
   | 外部キー嫌い               | foreign_key: false           | foreign_key: true      | テストで困るけど使っていこう |
   | メタデータ大増殖           | テーブルを連番で増やす       | 増やさない             |                              |
   | 曖昧なグループ             | group by A で select B       | Bが必要な理由を考える  |                              |
   | スパゲッティクエリ         | 複雑すぎるSQL                | シンプルにする         | 設計から見直そう             |
   | 外交特権                   | SQL言語だけ特別扱いする      | しない                 | DB管理者ってなに？           |
   | 臭いものに蓋               | エラーをないがしろにする     | しない                 |                              |

   アンチパターンだと決め付けるのではなく一長一短を知ることが大切。

** [[jaywalking.rb][信号無視]]

# #+INCLUDE: "jaywalking.rb" ruby
# #+INCLUDE: "https://raw.githubusercontent.com/akicho8/sql_anti_pattern/master/jaywalking.rb" ruby
# #+INCLUDE: "jaywalking.rb" example

#+BEGIN_SRC ruby
create_table :users do |t|
  t.string :friends_ids
end

user = User.create!
user.friends_ids = 2.times.collect { User.create!.id }.join(",")
user.friends_ids # => "2,3"
#+END_SRC

** [[multi_column_attribute.rb][複数列属性]]

#+BEGIN_SRC ruby
create_table :articles do |t|
  t.string :comment1
  t.string :comment2
  t.string :comment3
end
#+END_SRC

** [[index_shotgun.rb][闇雲インデックス]]

#+BEGIN_SRC ruby
create_table :users do |t|
  t.string :name, :index => true
  t.timestamps    :index => true

  t.index [:name, :created_at, :updated_at]
end
#+END_SRC

** [[phantom_files.rb][幻のファイル]]

#+BEGIN_SRC ruby
user = User.create!(:file_path => "path/to/file.png")
Pathname(user.file_path).exist? # => false
#+END_SRC

** [[readable_passwords.rb][読み取り可能パスワード]]

#+BEGIN_SRC ruby
user = User.create!(:password => "foo")
user.password_before_type_cast  # => "foo"
#+END_SRC

** [[thirty_one_flavors.rb][31のフレーバー]]

#+BEGIN_SRC ruby
create_table :users do |t|
  t.column :foo, "ENUM('a', 'b')"
end

User.create!(:foo => "a") # => #<User id: 1, foo: "a">
User.create!(:foo => "b") # => #<User id: 2, foo: "b">
#+END_SRC

** [[random_selection.rb][ランダムセレクション]]

#+BEGIN_SRC ruby
# NG
User.order("random()").take

# GOOD
User.offset(rand(User.count)).take
#+END_SRC

** [[rounding_errors.rb][丸め誤差]]

#+BEGIN_SRC ruby
create_table :users do |t|
  t.column :c1, :float
  t.column :c2, :double
  t.column :c3, "DECIMAL(65, 30)"
end

v = 5.5555555555555555555555555555555555555
user = User.create!(:c1 => v, :c2 => v, :c3 => v).reload
user.c1.to_d # => 0.555556e1
user.c2.to_d # => 0.555555555555556e1
user.c3.to_d # => 0.5555555555555555e1
#+END_SRC

** [[sql_injection.rb][SQLインジェクション]]

#+BEGIN_SRC ruby
id = "0 or name = 'admin'"
User.where("id = #{id}").take # => #<User id: 2, name: "admin">
#+END_SRC

** [[pseudokey_neat_freak][疑似キー潔癖症]]

#+BEGIN_SRC ruby
User.pluck(:id)                 # => [2, 4]
# 1から埋めるならもっと面倒なことになる
sql = "SELECT id + 1 FROM users WHERE (id + 1) NOT IN (SELECT id FROM users) LIMIT 1"
id = ActiveRecord::Base.connection.select_value(sql)
id                              # => 3
# INSERTでidが衝突するかもしれない
User.create!(:id => id)         # => #<User id: 3>
User.pluck(:id)                 # => [2, 3, 4]
#+END_SRC

** [[poor_mans_search_engine][貧者のサーチエンジン]]

#+BEGIN_SRC ruby
Article.where(["body like ?", "%日本%"])
#+END_SRC

** [[magic_beans][魔法の豆]]

user.rb が、これだけ。一方で users_controller.rb は1000行ある。

#+BEGIN_SRC ruby
class User < ActiveRecord::Base
end
#+END_SRC

** [[id_required][とりあえずID]]

Profile#user_id が一意であれば Profile#id は余計だろうという考えもあることを理解した。

#+BEGIN_SRC ruby
create_table :profiles, :id => false do |t|
  t.belongs_to :user
end

class User < ActiveRecord::Base
  has_one :profile
end

class Profile < ActiveRecord::Base
  self.primary_key = :user_id
  belongs_to :user
end

user = User.create!                 # => #<User id: 1>
user.create_profile!(:user => user) # => #<Profile user_id: 1>
#+END_SRC

** [[polymorphic_associations][typeにモデル名を入れるアレ]]

#+BEGIN_SRC ruby
create_table :users do |t|
end
create_table :comments do |t|
  t.belongs_to :commentable, polymorphic: true
end

class User < ActiveRecord::Base
  has_many :comments, as: :commentable
end

# あらゆるレコードにコメントできるモデル
class Comment < ActiveRecord::Base
  has_many :comments, as: :commentable # 自分に対してもコメントできるようにするため
  belongs_to :commentable, polymorphic: true
end

user = User.create!             # => #<User id: 1>
comment = user.comments.create! # => #<Comment id: 1, commentable_type: "User", commentable_id: 1>
comment.comments.create!        # => #<Comment id: 2, commentable_type: "Comment", commentable_id: 1>
comment = user.comments.create! # => #<Comment id: 3, commentable_type: "User", commentable_id: 1>
comment.comments.create!        # => #<Comment id: 4, commentable_type: "Comment", commentable_id: 3>

tt Comment.all.collect(&:attributes)
# >> +----+------------------+----------------+
# >> | id | commentable_type | commentable_id |
# >> +----+------------------+----------------+
# >> |  1 | User             |              1 |
# >> |  2 | Comment          |              1 |
# >> |  3 | User             |              1 |
# >> |  4 | Comment          |              3 |
# >> +----+------------------+----------------+
#+END_SRC

** [[keyless_entry.rb][外部キー嫌い]]

Article#user_id に意図しない値が入らないように心配するなら foreign_key: true にしときましょうということ。

#+BEGIN_SRC ruby
create_table :articles do |t|
  t.belongs_to :user, :foreign_key => true
end

Article.create!(:user_id => 0) rescue $! # => #<ActiveRecord::InvalidForeignKey: Mysql2::Error: Cannot add or update a child row: a foreign key constraint fails (`__test__`.`articles`, CONSTRAINT `fk_rails_3d31dad1cc` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`)): INSERT INTO `articles` (`user_id`) VALUES (0)>
# >>    (10.8ms)  CREATE TABLE `articles` (`id` int AUTO_INCREMENT PRIMARY KEY, `user_id` int,  INDEX `index_articles_on_user_id`  (`user_id`), CONSTRAINT `fk_rails_3d31dad1cc`
# >> FOREIGN KEY (`user_id`)
# >>   REFERENCES `users` (`id`)
# >> ) ENGINE=InnoDB
#+END_SRC

** [[metadata_tribble.rb][メタデータ大増殖]]

   NG

#+BEGIN_SRC ruby
(2000...2100).each do |year|
  create_table "users_#{year}" do |t|
  end
end

User.table_name = :users_2016
User.create!                    # => #<User id: 1>

User.table_name = :users_2017
User.create!                    # => #<User id: 1>
#+END_SRC

   速度が問題なら次のようにパーティション分割する。ただAR経由でこの処理を書こうとすると大変。

#+BEGIN_SRC sql
CREATE TABLE users (
 id INTEGER AUTO_INCREMENT NOT NULL,
 created_at DATETIME,
 PRIMARY KEY (id, created_at)
);

ALTER TABLE users PARTITION BY HASH (YEAR(created_at)) PARTITIONS 3;
EXPLAIN PARTITIONS SELECT * FROM users;
#+END_SRC

|----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------|
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
|----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------|
|  1 | SIMPLE      | users | p0,p1,p2   | index | NULL          | PRIMARY |       9 | NULL |    1 |   100.00 | Using index |
|----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------|

** [[ambiguous_groups.rb][曖昧なグループ]]

同じ name のレコードは複数あったかもしれないのに、どうして id が特定できたのか。MAX ではなく AVG を使って集約したと考えてみると、id が特定できた違和感を得やすい。

#+BEGIN_SRC ruby
sql "SELECT id, AVG(score) FROM users GROUP BY name" # => [{"id"=>2, "AVG(score)"=>1.5}, {"id"=>4, "AVG(score)"=>3.5}]
#+END_SRC

MySQL の場合はエラーにしてくれる。

#+BEGIN_SRC ruby
#<ActiveRecord::StatementInvalid: Mysql2::Error: Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column '__test__.users.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by: SELECT id, AVG(score) FROM users GROUP BY name>
#+END_SRC

** [[spaghetti_query.rb][スパゲッティクエリ]]

   - JOINの数に累乗して行が増えていくので気をつけろ
   - 行数は COUNT ^ (JOIN数 + 1) になる
   - 無理に一つにまとめようとすると破綻
   - なるべくシンプルに

#+BEGIN_SRC ruby
sql <<~EOT                      # => [{"COUNT(*)"=>2}]
SELECT COUNT(*) FROM favorites
EOT
sql <<~EOT                      # => [{"COUNT(*)"=>4}]
SELECT COUNT(*) FROM favorites
LEFT JOIN favorites USING (user_id)
EOT
sql <<~EOT                      # => [{"COUNT(*)"=>8}]
SELECT COUNT(*) FROM favorites
LEFT JOIN favorites USING (user_id)
LEFT JOIN favorites USING (user_id)
EOT
sql <<~EOT                      # => [{"COUNT(*)"=>16}]
SELECT COUNT(*) FROM favorites
LEFT JOIN favorites USING (user_id)
LEFT JOIN favorites USING (user_id)
LEFT JOIN favorites USING (user_id)
EOT
#+END_SRC

** [[see_no_evil.rb][臭いものに蓋]]

#+BEGIN_SRC ruby
User.count rescue 0
#+END_SRC
